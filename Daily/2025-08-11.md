---
tags:
  - Программирование
  - golang
  - Введение
  - Слайсы
  - Массивы
  - Мапы
создал заметку: 2025-08-11
---
### Начнём страдания заново?
#### Здесь будет мини конспект того, что я прочитал)
###### [Прочитал здесь](https://github.com/goavengers/go-interview)

##### Общее
1. Какие основные отличия есть у Go перед языками Java, Python?
   Если охарактеризовать Go одним предложением, то можно сказать так: «Похож на Python, но быстрее и с лучшим параллелизмом». Как и Python, Go рассчитан на интенсивное использование функций, что позволяет разработчикам сравнительно быстро создавать мощную функциональность.
   Однако, в отличие от Python, Go — компилируемый язык (технически Python также компилируется, но не в традиционном смысле). Как правило, это сокращает время выполнения программного кода.
   Удобный параллелизм. (собственные встроенные подпрограммы, goroutine)
   Пожалуй одним из главных отличий от Go (кроме синтаксиса), является объектно-ориентированная природа языка Java и то, что, для достижения кроссплатформенности, она работает на виртуальной машине JVM (Java Virtual Machine). В то же время Go программа исполняется в своем внутреннем Runtime и в Go нет классов с конструкторами. Вместо экземпляра методов, иерархии наследия классов и динамического метода, Go предоставляет структуры и интерфейсы.
   В то время как в Go для достижения параллелизма есть горутины (goroutine) и каналы (channels), а вся "тяжелая" работа лежит на планировщике (sheduler) исполняемой программы.
2. Какие преимущества и недостатки есть у Go? (объективные)
   *Преимущества*
   - Много встроенных инструментов для разработчиков.
   - Большое количество библиотек
   - Высокая производительность.
   - Надёжность
   *Недостатки*
   - Ограниченный функционал:
     Область применения языка Go — сетевые и серверные приложения. А вот с созданием графических интерфейсов он справляется плохо. Поэтому полностью написать на Go пользовательское приложение будет сложно из-за ограниченных возможностей, да и в целом он неприменим для многих задач. Его нужно использовать с умом и там, где он действительно нужен.
   - Простота.

##### Слайсы и массивы
__Массив__ в Go представляет собой структуру данных, состоящую из упорядоченной последовательности элементов, **емкость которой определяется в момент создания**. После определения размера массива его нельзя изменить.

**Срез** — это __версия массива с переменной длиной__, дающая разработчикам дополнительную гибкость использования этих структур данных. Срезы — это то, что обычно называют массивами в других языках.

*Зачем же тогда массивы?*
 Хотя из-за фиксированной длины массивов они не отличаются гибкостью в использовании, одноразовое выделение памяти позволяет повысить скорость и производительность вашей программы. В связи с этим, разработчики обычно используют массивы при оптимизации программ, в том числе, когда для структур данных не требуется переменное количество элементов.

Массив [2]int != [3]int 

``` go
oceans := make([]string, 3, 5) // output: [ "" "" "" ], len: 3, cap: 5
```

1. Как устроен слайс? А как массив?
   **Cлайс** - это **структура** go, которая включает в себя ссылку на **базовый массив**, а также две переменные len(length) и cap(capacity).
   **len** - это длина слайса - то количество элементов, которое в нём сейчас находится. **cap** - это ёмкость слайса - то количество элементов, которые мы можем записать в слайс сверх len без его дальнейшего расширения.
	``` go
	// структура слайса
	type slice struct {
		array unsafe.Pointer
		len   int
		cap   int
	}
	```
   **Массив** - это **последовательно выделенная область памяти.** Частью типа array является его размер, который в том числе является не изменяемым.
2. Как можно создать слайс? Что такое zero-value и какое оно у слайса? nil слайс?
    - Способы создания:
	``` go
	var nums []int 			// nil slice, длина 0 емкость 0
	var nums = []int{1, 2, 3} // слайс с 3 значениями, длина 3, емкость 3
	
	nums := []int{1, 2, 3} 	// тоже самое, что и выше, слайс с 3 значениями и емкостью 3
	
	nums := make([]int{}, 0, 3) // слайс без значенией но с емкостью 3
	nums := make([]int, 3) 	  // слайс с длиной 3 и с емкостью 3
	
	var (
		nums = make([]int{}, 0, 3) 	// аналог выше
		nums = make([]int, 3)		// аналог выше
	)
	```
    - **Zero-value** - переменным, объявленным **без явного начального значения,** присваивается нулевое значение.
	``` go
	var i int
	var f float64
	var b bool
	var s string
	var p *int
	var t time.Time
	
	fmt.Printf("%v %v %v %q %v %v\n", i, f, b, s, p, t)
	// output: 0 0 false "" <nil> 0001-01-01 00:00:00 +0000 UTC
	```
    - **nil слайс**. В Go с nil слайсом можно соверщать те же операции, которые могли бы делать с инициализированным слайсом
	``` go
	var slice []int
	
	fmt.Println(len(slice), cap(slice)) // output 0 0
	
	slice = append(slice, 10)
	
	fmt.Println(slice, len(slice), cap(slice)) // output [ 10 ] 1 1
	```
3. Как проверить слайс на пустоту?
   Самый надежный спосб проверить слайс на пустоту в большинчтве случаем - это вроверить его длину на ноль.
	``` go
	var a []int
	
	// не правильно, т.к. есть len = 0, cap != 0
	fmt.Println(a == nil) // true
	
	// а если так
	a := []int{}
	fmt.Println(a == nil) // false
	
	// поэтому правильно так
	fmt.Println(len(a) == 0) // true
	```
4. Как работает базовая функция append для слайсов? Можно ли применить к массивам? Напишите свою функцию append.
   Функция принимает на вход слайс и переменное количество элементов для добавления в слайс. Append расширяет слайс за пределы его len, возвращая при этом новый слайс.
	
	``` go
	// функция append
	func append(slice []Type, elems ...Type) []Type
	```
   Если количество элементов, которые мы добавляем в слайс, не будет превышать cap, вернется новый слайс, который ссылается на тот же базовый массив, что и предыдущий слайс. Если количество добавляемых элементов превысит cap, то вернется новый слайс, базовым для которого будет новый массив.
	``` go
	// в данном блоке кода продемонстрирована работа функции append
	
	// создаем слайс с capacity равным 3 и длиной 0
	slice := make([]int, 0, 3) 	// len: 0, cap: 3
	
	// далее заполняем слайс тремя элементами
	slice = append(slice, 1) 	// len: 1, cap: 3
	slice = append(slice, 2, 3) 	// len: 3, cap: 3
	
	// получаем ожидаемый результат
	fmt.Println(slice) // output [ 1, 2, 3 ]
	
	// окей, теперь попробуем присводить слайс другому слайсу
	// помним то, что слайс является структурой из трех элементов len, cap и указателем н первый элемент массива
	// поэтому в sliceCopy мы получаем скопированные значение len и cap, а так же указатель на тот же массив, что и у переменной slice
	sliceCopy := slice
	
	// пробуем менять первый элемент в новом слайсе
	sliceCopy[1] = 10
	
	// убеждаемся, что в обоих слайсах изменились значения, все из-за базового массива
	fmt.Println(slice, sliceCopy) // output: slice: [ 1, 10, 3 ] sliceCopy: [ 1, 10, 3 ]
	
	// хорошо, теперь пробуем добавить новый элемент в первый слайс
	slice = append(slice, 4)
	// тут у нас функция append "видит", что мест больше нет и увеличивает cap в двое, увеличивает len на один
	// и создает новый базовый массив с местимостью в 6 элементов, что и видим на печати
	fmt.Println(slice) // output: [ 1, 10, 3, 4] len: 4, cap: 6
	// но что случилось тут? ничего, просто ничего, теперь первая переменная смотрит на другой базовый массив и они больше никак не связаны
	fmt.Println(sliceCopy) // output: [ 1, 2, 3 ] len: 3, cap: 3
	
	// точно не связаны? ну давай убедимся! пробуем менять значения первых элементов в обоих слайсах
	sliceCopy[0] = 50
	slice[0] = 80
	
	// убедились? :)
	fmt.Println(slice, sliceCopy) // output: slice: [ 80, 10, 3, 4 ] sliceCopy: [ 50, 10, 3 ]
	```
	Теперь напишем свою функцию:
	``` go
	// она будет проще, только с добавлением одного элемента
	func main() {
		fmt.Println(Append([]int{1, 2, 3}, 4))
	}
	
	func Append[T any](dst []T, el T) []T {
		var res []T
		
		resLen := len(dst) + 1
		if resLen <= cap(dst) {
			res = dst[:resLen]
		} else {
			resCap := resLen
			if resCap < 2*len(dst) {
				resCap = 2 * len(dst)
			}
		
			res = make([]
			T, resLen, resCap)
			copy(res, dst)
		}
		
		res[len(dst)] = el
		return res
	}
	```
5. Как можно скопировать слайс? Что такое функция copy? Как добиться аналогичного поведения copy с помощью append?
   Встроенная функция copy копирует элементы в целевой срез dst из исходного среза src.
	``` go
	func copy(dst, src []Type) int
	```
   Возвращает количество скопированных элементов, которое будет минимумом len(dst) и len(src). Результат не зависит от того, перекрываются ли аргументы.
	``` go
	// Копировать из одного среза в другой
	var slice = make([]int, 3)
	num := copy(slice, []int{0, 1, 2, 3}) 
	fmt.Println(num, slice) // output: num == 3, slice == []int{0, 1, 2}
	```
   А вот тут через append ^-^:
	``` go
	slice := make([]byte, 0, len(a))
	slice = append(c, []int{0, 1, 2, 3}...)
	
	fmt.Println(slice) // output: slice == []int{0, 1, 2}
	```
6. Как можно слить два слайса?
   В прошлом пункте мы использовали секретные "..." - Это мы разделили по элементам срез
	``` go
	s1 := []int{1, 2, 3}
	s2 := []int{4, 5, 6}
	
	s3 := append(s1, s2...)
	fmt.Println(s3) // output: [ 1, 2, 3, 4, 5, 6 ]
	```
7. Как можно нарезать слайс? Какие есть нюансы, подводные камни?
   В Go можно сделать подслайз из слайса или массива:
	``` go
	slice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	subSlice := slice[3:8] // [ 4, 5, 6, 7, 8 ]
	```
   Но что будет, если мы изменим значение под слайса или еще хуже, добавим туда элементы через функцию append?
	``` go
	subSlice[0] = 101

	fmt.Println(slice) // [1 2 3 101 5 6 7 8 9 10]
	fmt.Println(subSlice) // [101 5 6 7 8]
	```
	
   Видим, что в базовом слайсе тоже поменялись значения, а все потому, что у под слайса все тот же базовый массив, а для подслайса нулевой элемент это элемент под индексом 3 в базовом. Примерно такое же поведение наблюдается у функции append, если его применить к под слайсу базового слайса:
	``` go
	slice := make([]int, 10, 25)
	subSlice := slice[3:5] // [ 0, 0, 0, 0, 0 ]

	fmt.Println(len(slice), cap(slice)) // 10 25
	fmt.Println(len(subSlice), cap(subSlice)) // 2 22

	subSlice = append(subSlice, 11)

	fmt.Println(slice) // [0 0 0 0 0 11 0 0 0 0]
	fmt.Println(subSlice) // [0 0 11]
	```
   причина данного поведения в том, что у обоих слайсов один базовый массив, а так же у под слайса своя "копия" слайса с полями len и cap и когда мы пытаемся добавить в дочерний слайс элемент, при условии, что в родительском хватает емкости, мы просто перезаписываем значение в базовом массива.

##### Мапы
Операции `Insert(Key)`, `Remove(Key)`, `LookUp(Key)` должны выполняться за константное время.
1. Что такое Map? Как устроен в Go? Желательно приблизительно понимать структуру (type hmap struct) и его поля
   В Go `map[K]V` — это **хеш-таблица** с открытой адресацией и бакетами.  
   Она реализована на уровне рантайма как структура `hmap`.
	``` go
	type hmap struct {
	    count     int            // Кол-во элементов
	    flags     uint8          // Служебные флаги (итерация, эвакуация и т.д.)
	    B         uint8          // log₂(кол-ва бакетов)
	    noverflow uint16         // Примерное кол-во переполненных бакетов
	    hash0     uint32         // seed для хеш-функции - условие безопасности
	
	    buckets    unsafe.Pointer // Массив бакетов [2^B] - тут ссылка на сами бакеты, ибо всё это лишь header
	    oldbuckets unsafe.Pointer // Старые бакеты при эвакуации
	    nevacuate  uintptr        // Сколько бакетов уже эвакуировано
	    extra      *mapextra      // Редкие случаи (например, для типа с pointer-эвакуацией)
	}
	
	```
   **Бакет** — это массив пар `(key, value)` плюс метаданные (tophash), чтобы ускорить поиск.  
   В одном бакете обычно **8 элементов**.
   Т.к. Дженериков тогда ещё не было, то у `maptype` ключ и значения хранятся в `unsafe.Pointer`, а вся необходимая информация по типу данных заключена в структурку `_type`. 
   ###### Low order bits (LOB)
   Hash(Key) = 5461, а бакетов у нас всего 4. Что же делать? `%4`! Но как сделать это быстро? Тут то нам и понадобится `B` (log(bucket.count())). Мы посмотрим на последние `B` битов нашего хэша в двоичной записи и сопоставим с бакетом, который нам нужен.
   Чтобы посмотреть мы используем битовую маску `1<<B - 1`, после чего мы накладываем её при помощи побитовой конъюнкции.
   ###### Структура бакета
   У бакета есть свой header, в котором хранится небольшая информация по тому, что он хранит. При поиске элемента функция сначала заглянет туда, если там не найдёт, то дальше глядеть не будет. А ежели в хедере была инфа по нашему элементу, то посмотрим уже на массив значений (8 значений, более тяжеловесный. Сначала все ключи, потом все значения).
   ![[Pasted image 20250813113126.png]]
   Для прохождения такого списка мы используем ссылочную арифметику. Тут нам и пригодится наша структурка `_type`, ведь там хранится информация по нашим типам: на сколько бит/байт прыгать. (просто к `uintptr` прибавляем размер, после чего обратно в unsafe.Pointer).
   ###### Переполнение бакетов
   Если нам нужно добавить 9ый элемент, то что будет?
   В конец переполненного бакета мы запихиваем ссылку на новый бакет.
   А в какой момент нам создать новый бакет, ведь если мы будем создавать их, когда закончится предыдущий, то может произойти то, то мы будем просто наращивать один и тот же. А это вообще не прикольно, ибо из константной операции она превратится в линейную.
   Тригером для роста количества бакетов становится случай, когда среднее количество элементов достигает числа 6.5. Тогда начинается эвакуация данных. А это медленно. Поэтому эвакуация происходит при добавлении нового элемента или удаления имеющегося. (Опа, равномерно по новым бакетам)
   Но теперь у нас проблема. Есть `OldBuckets` и `NewBuckets`, что не есть хорошо, ибо смотреть нужно в 2 места, да и места занимает много. Потому **Аллоцируй память заранее!**
	``` go
	m := make(map[int]int, 1000)
	```
	
2. Что такое хеш-функция?
   Хеш-функция — это алгоритм, который преобразует ключ `K` в **фиксированное число** (хеш), по которому Go определяет, в какой бакет положить элемент.
   - Детерминизм (1 значение = 1 хэш)
   - Равномерность (меньше коллизий)
   - Эффективность (БЫСТРЕЕЕЕ!!!)
   - Ограниченность (Ключи в пределах таблицы)
   - Криптоустойчивость (Нас в обратную сторону не пройдём)
   - Использует случайный `hash0` seed (чтобы защититься от хеш-атак)
3. Почему нельзя брать ссылку на значение, хранящееся по ключу в map?
   Такое нельзя
	``` go
		m := map[string]int{"a": 1}
		p := &m["a"] // ❌ ошибка
	```
	**Go может перемещать значения внутри map** (при расширении, **эвакуации** и т.д.).  
	Если бы мы получили ссылку, то при изменении map она стала бы указывать на уже невалидную память.
	
	А вот функция `mapaccess1` возвращают указатель. Что не так?
	Они его сразу разыменовывают и указатель удаляется.
4. Что такое эвакуация, и в каком случае она будет происходить?
   **Эвакуация** — это процесс **переноса элементов** из старого массива бакетов (`oldbuckets`) в новый (`buckets`) при увеличении размера хеш-таблицы.
   Происходит, когда:
   - количество элементов в среднем > 6.5 на бакет
   - слишком много переполненных бакетов (`noverflow` большое)
   Эвакуация в Go **постепенная**: При каждой операции (`Set`, `Get`, `Delete`) эвакуируется часть старых бакетов, чтобы избежать длинных стопов.
5. Какие есть особенности синтаксиса получения и записи значений в map?
   **Особенность**: `m["key"]` при чтении всегда возвращает **нулевое значение типа V**, если ключа нет.
	``` go
	m := map[string]int{}

	// Получение
	v := m["key"]            // v = 0, если ключа нет
	v, ok := m["key"]        // ok = false, если нет ключа

	// Запись
	m["key"] = 42

	// Удаление
	delete(m, "key")
	```
6. Как происходит поиск по ключу в map?
   - Вычисляется хеш ключа.
   - По `B` младшим битам определяется номер бакета.
   - В бакете по `tophash` (первые 8 бит хеша) ищем совпадение.
   - Если нет — идём в **overflow-бакет** (цепочка).
   - Если нашли ключ — возвращаем значение.
7. Каков порядок перебора map?
   Случайный.
   - Итератор ходит по нашим бакетам, а ходит он как по новым, так и по старым бакетам. 
   - Также обход зависит и от хэш-функции, что мы использовали.
   - другое.
   Получается, что обход зависит от многих факторов, которые просчитать заранее - невозможно.
   Поэтому разработчики решили ещё более сильно зарандомить и ввели функцию `fastrand()`, которая выбирает случайное место, с которого начнётся итерация по мапе.
   P.S. `fmt.Println(mapa)` - сортирует мапу, хоть и получает её в случайном виде.
8. Что будет происходить при конкуррентной записи в map? Как можно решить эту проблему?
   Если **два горутины одновременно пишут в map** без синхронизации:
   - Go выдаст `fatal error: concurrent map writes`
   - Это защита от race condition в рантайме
   - Одновременное чтение/запись тоже опасно (может паникнуть)

	Возможно здесь про то, как решаются коллизии:
	- Метод открытой адресации:
	  Зависит от метода обхода (можем дважды хешировать, можем прибавлять единицу, крадратная)
	  От внутреннего размера массива (Мы же превращали `ключ` в `id`  хранения в массиве. А если этот массив слишком большой? - много неиспользуемой памяти! Маханький? - много коллизий)
	  Быстрый обход
	  Меньший расход памяти (не храним ссылку на следующий элемент)
	- Метод цепочек
	  Много памяти
	  Медленный обход
	  Простая реализация
9. Как защититься от ошибки во время конкурентной записи в map?
    - sync.Mutex
	``` go
	var mu sync.Mutex
	m := make(map[string]int)
	
	mu.Lock()
	m["a"] = 1
	mu.Unlock()
	```
    - sync.RWMutex
	``` go
	var mu sync.RWMutex
	mu.RLock()
	v := m["a"]
	mu.RUnlock()
	```
    - sync.Map
	``` go
	var sm sync.Map
	sm.Store("a", 1)
	v, ok := sm.Load("a")
	```