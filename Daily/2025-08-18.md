---
tags:
  - Программирование
  - golang
  - Продуктивность
создал заметку: 2025-08-18
---
### Общие вопросы по Go

1. Зачем используется ключевое слово defer в Go?
   `defer` откладывает вызов функции до момента выхода из текущей функции (при `return` или при панике). 
   Типичные применения:
   - Освобождение ресурсов (`Close()`, `Unlock()`).
   - Обработка паник (`recover`).
   - Логирование выхода из функции.
2. Каков порядок возврата при использовании несколько функций с defer в рамках одной внешней функции?
   Стек. LIFO.
	``` go
	func test() {
		defer fmt.Println("1")
		defer fmt.Println("2")
		defer fmt.Println("3")
	}
	```
	3
	2
	1
3. Как передаются значения в функции, перед которыми указано ключевое слово defer? Пример:
	```go
	func main() {
		nums := 1 << 5 // 32
	
		defer fmt.Println(nums) // туть как?
	
		nums = nums >> 1 //16
	
		fmt.Println("done")
	}
	```
	Здесь будет копия, поэтому `32` и выведет.
	``` go
	defer func() {
	    fmt.Println(nums)
	}()
	```
4. Какие бывают способы синхронизации данных в Go? (про каналы тоже не забываем)
   - **sync.Mutex** / **sync.RWMutex** — блокировки.
   - **sync.WaitGroup** — ожидание завершения горутин.
   - **sync.Once** — выполнение кода один раз.
   - **sync.Cond** — условные переменные.
   - **sync.Map** — потокобезопасная map.
   - **sync/atomic** — атомарные операции.
   - **Каналы (channels)** — средство обмена данными и синхронизации горутин.
5. Что такое mutex, какие они бывают и как их использовать?
   `Mutex` = взаимное исключение (mutual exclusion)
   - **sync.Mutex** — обычная блокировка (`Lock/Unlock`).
   - **sync.RWMutex** — разделяемая блокировка:
     - `RLock`/`RUnlock` для чтения (несколько одновременно).
     - `Lock`/`Unlock` для записи (только один поток).
6. Что такое atomics, какие бывают и как и когда их лучше использовать?
   Пакет `sync/atomic` предоставляет **низкоуровневые атомарные операции**:
   - `atomic.AddInt32`, `atomic.AddInt64`
   - `atomic.LoadInt32`, `atomic.StoreInt32`
   - `atomic.CompareAndSwapInt32` (CAS)
	Использовать, когда:
	- нужна **максимальная скорость**,
	- операции **простые** (например, счётчик). 
	Для сложных структур — лучше `Mutex`.
7. Что такое sync.Map?
   Специальная потокобезопасная `map`, оптимизированная под **много чтений и мало записей**.
   Методы:
   - `Store(key, value)`
   - `Load(key)`
   - `Delete(key)`
   - `Range(func(k, v any) bool)`
8. Что такое lock-free структуры данных, и есть ли в Go такие? Если интересно.
   Lock-free = структуры, работающие без мьютексов (используют атомики, CAS). В Go стандартной библиотекой почти не предоставляются lock-free коллекции, кроме `sync.Map` (частично lock-free). 
   Есть сторонние библиотеки (например, lock-free queues).
9. Как можно обработать панику с помощью defer и recovery?
   `recover` ловит панику, если вызван **внутри `defer`**.
	``` go
	func safe() {
	    defer func() {
	        if r := recover(); r != nil {
	            fmt.Println("Поймали панику:", r)
	        }
	    }()
	    panic("что-то пошло не так")
	}
	```
10. Что такое context в Go? Какие бывают context в Go? Когда их нужно использовать и зачем?
    Пакет `context` используется для управления временем жизни горутин (дедлайны, время выхода).
    Виды:
    - `context.Background()` — корневой контекст (обычно в `main`).
    - `context.TODO()` — заглушка.
    - `context.WithCancel(parent)` — отмена вручную.
    - `context.WithDeadline(parent, time)` — с дедлайном.
    - `context.WithTimeout(parent, duration)` — с таймаутом.
    - `context.WithValue(parent, key, val)` — хранение значений (например, request ID).
	Используется для:
	- отмены долгих операций,
	- таймаутов в запросах,
	- проброса метаданных между горутинами.
11. Что такое указатели? Как передаются параметры в функцию по указателю или по значению? Какие типы неявно передаются как указатель? Как передать по указателю?
    Указатель (`*T`) хранит адрес значения типа `T`.
    Передача по указателю = можно изменить значение в функции.
	``` go
	func set(x *int) {
	    *x = 10
	}
	
	func main() {
	    a := 5
	    set(&a)
	    fmt.Println(a) // 10
	}
	```
	В Go **все параметры передаются по значению**.
	Но есть исключения:
	- **срезы (`slice`)**: содержат указатель на массив.
	- **map**: внутри ссылка на хэш-таблицу.
	- **chan**: ссылка на канал.
	- **func**: содержит указатель на код и замыкания.

	То есть, передача их в функцию выглядит как "по ссылке".
12. Что такое пакеты (package) в Go? Как их создавать и импортировать?
    Пакет (`package`) = модуль кода.
    Создаётся в папке, где файлы начинаются с `package name`. 
    Импорт:
	``` go
	import "fmt"
	import "myapp/mypkg"
	```
13. Можно ли реализовать sync.Mutex и sync.WaitGroup на каналах? Как?
	``` go
	type ChanMutex struct {
	    ch chan struct{}
	}
	
	func NewChanMutex() *ChanMutex {
	    m := &ChanMutex{ch: make(chan struct{}, 1)}
	    m.ch <- struct{}{} // кладём "микрофон"
	    return m
	}
	
	func (m *ChanMutex) Lock() {
	    <-m.ch
	}
	
	func (m *ChanMutex) Unlock() {
	    m.ch <- struct{}{}
	}
	```

	```go
	type ChanWaitGroup struct {
	    ch chan struct{}
	    n  int
	}
	
	func (wg *ChanWaitGroup) Add(delta int) {
	    wg.n += delta
	    if wg.ch == nil {
	        wg.ch = make(chan struct{})
	    }
	}
	
	func (wg *ChanWaitGroup) Done() {
	    wg.n--
	    if wg.n == 0 {
	        close(wg.ch)
	    }
	}
	
	func (wg *ChanWaitGroup) Wait() {
	    <-wg.ch
	}
	```