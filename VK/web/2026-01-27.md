---
tags: 
создал заметку: "2026-01-27"
---
### Лекция от 16.10 Веб-Сервера
##### Что-то интересное
Если мы хотим, чтобы наш пользователь ходил только по https, то именно в nginx настраиваем редирект на 443 порт.
**nginx** - всегда занимает 1 процесс (1 ядро). 1 http запрос = 1 поток. Эти потоки будут на этом же одном ядре.
**nginx** = revers proxy. Получаем запрос, отправляемся спрашивать у кого-то, ждём его ответа и перенаправляем.
##### Немного статистики
![[Pasted image 20260127164718.png]]
3ее - для облачных провайдеров. 
2ое - (как помним с лекции по IT-проектам Исходники писал человек, который не любит людей)
- `Apache` - prefork, worker, threads, C
- `Tomcat`, `Jetty` - threads, Java
- `Starman`, `Gunicorn` - prefork, языки высокого уровня
- `Nginx`, `LiteSpeed` - асинхронные, С
- `Node.JS`, `asyncio` - асинхронные, языки высокого уровня (вторая для питона)
##### Настойка nginx
- Будем рассматривать его, т.к. он пришёл для решения своевременных задач по обработке огромного количества пользователей. Тогда была проблема **C10k** (проблема 10.000 соединений) - APache не мог обработать столько. Nginx  - легковесный веб-сервер.

- Нужны порты 80 и 443 для http и https соответственно.
- На линуксе лежит в папочке `etc/nginx` - стандартный путь.
- **Worker** - дочерний процесс/поток.
- Для сторонних конвигов кладём их рядом соседнюю папку `include /etc/nginx/sites-enabled/*` или `include /etc/nginx/servers/*`
- `reload` - мягкий перезапуск, когда воркеры по очереди выключаются-включаются, когда основной процесс остаётся рабочим.
- `status` - статус мастера и всех воркеров
- иногда Error-логи и Access-логи выключают, так как логов порой бывает слишком много. `/var/log/nginx/error.log(access.log)`
- Иногда выделяются отдельные репы для хранения логов. Или использовать Ansible

##### Процессы
- Master = root, 1 процесс
	- Чтение и валидация конфига 
	- Открытие сокетов и логов
	- Запуск и управление дочерними процессами (вопкерами)
- Worker = 1 поток в nginx (В apache - это были отдельные процессы)
	- Обработка входящих запросов
	- **Работают конкурентно** 

У Apache - процессы, т.к. он может запускать интерпретаторы языков
Nginx такого не может, он запускает только самого себя.

##### Пример рабочего цикла веб-сервера
![[Pasted image 20260127172401.png]]
- Приходит запрос;
- Находим порт, где крутится nginx;
- **location** - путь до ресурса;
- Проверка доступа;
- Чтение;
- Фильтры - Тут же получаем ответы;
- Отправка ответа;
- Записываем логи;
- Чистимся. Поток в nginx пропадает из памяти полностью.

##### Модульная архитектура
- Веб-сервер - не монолитный
- Динамическая загрузка модулей - LoadModule. GeoIP. Некоторые сайты при заходе из России выдают 502 ошибку. Её отдаёт именно nginx
- Mod_cgi

##### Пример настройки
![[Pasted image 20260127231336.png]]
##### Секции и директивы
- `http` - конфигурация для НТТР сервера.
- `server` - конфигурация домена (вирт. Хоста).
- `server_name` - имена доменов.
- `location` - локейшен, группа URL.
- `root`, `alias` - откуда нужно брать файлы. root-только в этой папке, без поддиректорий. alias - для поддиректорий.
- `error_log` - лог ошибок сервера.
- `access_log` - лог запросов. Успешных.

Локейшены выбираются в том порядке, что мы написали. Поэтому просто `/` писать последним. Выбирается по первому полному совпадению.

##### Немного про права доступа

#### Модели обработки сетевых запросов
![[Pasted image 20260127233905.png]]
##### Блокирующий ввод-вывод
![[Pasted image 20260127234015.png]]Как решить проблему с блокировками?
- Многопоточность.
- Множество процессов. pool of workers. Это больше для Apache.
- Комбинированный подход

##### Неблокирующий ввод-вывод
![[Pasted image 20260127235140.png]]
Насколько я понял, это и есть Event-driven разработка. 
##### Мультиплексирование
Приложение может слушать не один сокет, а зарезервировать несколько файлов (в линухе процессы = файлы) и слушать именно их.
**Сокет** - абстракция!! просто файл, в который мы пишем или из которого читаем.

`1:35:07`

#### Frontend и Backend
##### Клиент-серверная архитектура
![[Pasted image 20260128145644.png]]
- то, что посередине - наш nginx
- под ним, скорее всего, сервер, который раздаёт статику
- backend = application server

#### Application server
Это и есть наши backend.
- Его роль заключается в исполнении бизнес-логики и генерации динамических документов
- Именно он запускает обработчик (это может быть функция, класс, метод или другая технология, которая решает нашу проблему)
- Бизнес-логика - совокупность правил, принципов, зависимостей поведения объектов предметной области.

##### Протоколы запуска приложений
- Servlets и др. специализированные API
- mod_perl, mod_python, mod_php - это для apache, когда можем интерпретировать (или компилить) прям на веб сервере
- CGI (Common Gateway Interface) - маленький сервер, который является прослойкой между nginx и application сервером.
- FastCGI и SCGI. 
- PSGI, **WSGI**, Rack

##### CGI (Common Gateway Interface)
- Метод, QueryString, заголовки запроса - через переменные окружения. Только стандартные методы -> долго.
- Тело запроса передается через STDIN
- Заголовки и тело ответа возвращаются через STDOUT
- HТТР код ответа передается через псевдозаголовок Status
- Поток ошибок STDERR направляется в лог ошибок сервера

![[Pasted image 20260128160118.png]]

##### FastCGI
отличается тем, что наша функция как бы крутиться. Не весь код с нуля будет запущен
![[Pasted image 20260128160451.png]]

##### WSGI (Web Server Gateway Interface)
Актуальный протокол.  
Запускаем из фоново работающего application сервера.
- Обработчик - функция или класс (callable)
- Метод, QueryString, заголовки запроса - через аргумент environ
- Тело запроса передается через file-handle wsgi.input
- НТТР код ответа и заголовки ответа передаются через вызов функции start_response
- Тело ответа возвращается в виде списка (iterable) из обработчика
- Поток ошибок должен быть направлен в file-handle wsgi.stderr

#### Как вообще выглядит общение
![[Pasted image 20260128161022.png]]
- Web Server = nginx
- Application сервер выбирает, какой WSGI worker обработает наш запрос
- Framework = Django
- Application = код, написанный нами
